(|unfold|)
(|fusion|
 (|fusion| 0
  (|fusion-1| NIL 3943030978
   (""
    (MEASURE-INDUCT-AND-SIMPLIFY "size(x)" ("x") :EXPAND "unfold" :IF-MATCH
     ALL)
    NIL NIL)
   ((|wf_nat| FORMULA-DECL NIL |naturalnumbers| NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|fun| DEF-DECL "Range" |fusion| NIL)
    (|unfold| DEF-DECL "binary_tree" |unfold| NIL)
    (|reduce| ADT-DEF-DECL "[binary_tree[T] -> range]" |binary_tree_adt_reduce|
     NIL)
    (|binary_tree| TYPE-DECL NIL |binary_tree_adt| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|Range| FORMAL-TYPE-DECL NIL |fusion| NIL)
    (|well_fnd| TYPE-EQ-DECL NIL |unfold| NIL)
    (|smaller| TYPE-EQ-DECL NIL |unfold| NIL)
    (T FORMAL-TYPE-DECL NIL |fusion| NIL)
    (PRED TYPE-EQ-DECL NIL |defined_types| NIL)
    (|pred| TYPE-EQ-DECL NIL |defined_types| NIL)
    (|well_founded?| CONST-DECL "bool" |orders| NIL)
    (|measure_induction| FORMULA-DECL NIL |measure_induction| NIL)
    (S FORMAL-TYPE-DECL NIL |fusion| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|naturalnumber| TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|size| FORMAL-CONST-DECL "[S -> nat]" |fusion| NIL)
    (< CONST-DECL "bool" |reals| NIL))
   NIL))
 (|fun_induction| 0
  (|fun_induction-1| NIL 3943030978
   ("" (SKOSIMP)
    (("" (MEASURE-INDUCT+ "size(x)" ("x"))
      (("" (EXPAND "fun" +)
        (("" (PROP)
          (("" (INST? :IF-MATCH ALL)
            (("" (HIDE -2)
              (("" (ASSERT) (("" (INST?) (("" (PROP) NIL))))))))))))))))
    NIL)
   ((|pred| TYPE-EQ-DECL NIL |defined_types| NIL)
    (|well_founded?| CONST-DECL "bool" |orders| NIL)
    (|measure_induction| FORMULA-DECL NIL |measure_induction| NIL)
    (S FORMAL-TYPE-DECL NIL |fusion| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|naturalnumber| TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|size| FORMAL-CONST-DECL "[S -> nat]" |fusion| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|wf_nat| FORMULA-DECL NIL |naturalnumbers| NIL)
    (|fun| DEF-DECL "Range" |fusion| NIL)
    (|well_fnd| TYPE-EQ-DECL NIL |unfold| NIL)
    (|smaller| TYPE-EQ-DECL NIL |unfold| NIL)
    (T FORMAL-TYPE-DECL NIL |fusion| NIL)
    (PRED TYPE-EQ-DECL NIL |defined_types| NIL)
    (|Range| FORMAL-TYPE-DECL NIL |fusion| NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL))
   NIL)))
(|treesort|
 (|length_filter| 0
  (|length_filter-1| NIL 3943414340 ("" (INDUCT-AND-SIMPLIFY "x") NIL NIL)
   ((|list| TYPE-DECL NIL |list_adt| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (PRED TYPE-EQ-DECL NIL |defined_types| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (<= CONST-DECL "bool" |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|length| DEF-DECL "nat" |list_props| NIL)
    (|pred| TYPE-EQ-DECL NIL |defined_types| NIL)
    (|every| ADT-DEF-DECL "boolean" |list_adt| NIL)
    (|filter| DEF-DECL "(list_adt[T].every(p))" |filters| NIL)
    (T FORMAL-TYPE-DECL NIL |treesort| NIL)
    (|list_induction| FORMULA-DECL NIL |list_adt| NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|nnint_plus_posint_is_posint| APPLICATION-JUDGEMENT "posint" |integers|
     NIL)
    (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL)
    (|posint_plus_nnint_is_posint| APPLICATION-JUDGEMENT "posint" |integers|
     NIL))
   |shostak|))
 (|filter_length| 0
  (|filter_length-1| NIL 3943030978 ("" (INDUCT-AND-REWRITE! "x") NIL NIL)
   ((|list| TYPE-DECL NIL |list_adt| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|length| DEF-DECL "nat" |list_props| NIL)
    (|pred| TYPE-EQ-DECL NIL |defined_types| NIL)
    (PRED TYPE-EQ-DECL NIL |defined_types| NIL)
    (|every| ADT-DEF-DECL "boolean" |list_adt| NIL)
    (|filter| DEF-DECL "(list_adt[T].every(p))" |filters| NIL)
    (|below| CONST-DECL "bool" |treesort| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (- CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|above| CONST-DECL "bool" |treesort| NIL)
    (T FORMAL-TYPE-DECL NIL |treesort| NIL)
    (|list_induction| FORMULA-DECL NIL |list_adt| NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|nnint_plus_posint_is_posint| APPLICATION-JUDGEMENT "posint" |integers|
     NIL)
    (|posint_plus_nnint_is_posint| APPLICATION-JUDGEMENT "posint" |integers|
     NIL)
    (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL))
   NIL))
 (|unjoin_TCC1| 0
  (|unjoin_TCC1-1| NIL 3943030978
   ("" (SUBTYPE-TCC)
    (("" (USE "filters[T].length_filter")
      (("" (SIMPLIFY-WITH-REWRITES :REWRITES ("length")) NIL NIL)) NIL))
    NIL)
   ((|cdr| ADT-ACCESSOR-DECL "[(cons?) -> list]" |list_adt| NIL)
    (PRED TYPE-EQ-DECL NIL |defined_types| NIL)
    (|below| CONST-DECL "bool" |treesort| NIL)
    (|car| ADT-ACCESSOR-DECL "[(cons?) -> T]" |list_adt| NIL)
    (|length_filter| FORMULA-DECL NIL |filters| NIL)
    (|length| DEF-DECL "nat" |list_props| NIL)
    (|nnint_plus_posint_is_posint| APPLICATION-JUDGEMENT "posint" |integers|
     NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|cons?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL)
    (|list| TYPE-DECL NIL |list_adt| NIL)
    (T FORMAL-TYPE-DECL NIL |treesort| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL))
   NIL
   (|unjoin| SUBTYPE
    "filters[treesort.T].filter(treesort.y, treesort.below(treesort.a))"
    "smaller[treesort.T, list_adt[treesort.T].list, list_props[treesort.T].length](treesort.x)")))
 (|unjoin_TCC2| 0
  (|unjoin_TCC2-1| NIL 3943030979
   ("" (GRIND :REWRITES "length_filter")
    (("" (USE "length_filter") (("" (ASSERT) NIL NIL)) NIL)) NIL)
   ((|car| ADT-ACCESSOR-DECL "[(cons?) -> T]" |list_adt| NIL)
    (|above| CONST-DECL "bool" |treesort| NIL)
    (PRED TYPE-EQ-DECL NIL |defined_types| NIL)
    (|cdr| ADT-ACCESSOR-DECL "[(cons?) -> list]" |list_adt| NIL)
    (|length_filter| FORMULA-DECL NIL |treesort| NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL)
    (|posint_plus_nnint_is_posint| APPLICATION-JUDGEMENT "posint" |integers|
     NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (T FORMAL-TYPE-DECL NIL |treesort| NIL)
    (|list| TYPE-DECL NIL |list_adt| NIL)
    (|cons?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL)
    (|length| DEF-DECL "nat" |list_props| NIL))
   NIL
   (|unjoin| SUBTYPE
    "filters[treesort.T].filter(treesort.y, treesort.above(treesort.a))"
    "smaller[treesort.T, list_adt[treesort.T].list, list_props[treesort.T].length](treesort.x)")))
 (|quicksort_TCC1| 0
  (|quicksort_TCC1-1| NIL 3943030978
   ("" (TERMINATION-TCC) (("" (USE "length_filter") (("" (ASSERT) NIL)))) NIL)
   ((T FORMAL-TYPE-DECL NIL |treesort| NIL)
    (|list| TYPE-DECL NIL |list_adt| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (PRED TYPE-EQ-DECL NIL |defined_types| NIL)
    (|below| CONST-DECL "bool" |treesort| NIL)
    (|length_filter| FORMULA-DECL NIL |treesort| NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|length| DEF-DECL "nat" |list_props| NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|nnint_plus_posint_is_posint| APPLICATION-JUDGEMENT "posint" |integers|
     NIL))
   NIL
   (|quicksort| TERMINATION
    "treesort.quicksort(filters[treesort.T].filter(treesort.y, treesort.below(treesort.a)))"
    "NIL")))
 (|quicksort_TCC2| 0
  (|quicksort_TCC2-1| NIL 3943030978
   ("" (TERMINATION-TCC) (("" (USE "length_filter") (("" (ASSERT) NIL)))) NIL)
   ((T FORMAL-TYPE-DECL NIL |treesort| NIL)
    (|list| TYPE-DECL NIL |list_adt| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (PRED TYPE-EQ-DECL NIL |defined_types| NIL)
    (|above| CONST-DECL "bool" |treesort| NIL)
    (|length_filter| FORMULA-DECL NIL |treesort| NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|length| DEF-DECL "nat" |list_props| NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|nnint_plus_posint_is_posint| APPLICATION-JUDGEMENT "posint" |integers|
     NIL))
   NIL
   (|quicksort| TERMINATION
    "treesort.quicksort(filters[treesort.T].filter(treesort.y, treesort.above(treesort.a)))"
    "NIL")))
 (|quicksort_by_fusion| 0
  (|quicksort_by_fusion-2|
   "The previous proof with measure-induct-and-simplify gets stuck so this one does measure-induct+ and then a few manual steps."
   3943031905
   (""
    (SIMPLIFY-WITH-REWRITES :REWRITES
     ("flatten" "mktree" "fusion" "fusionqsort"))
    (("" (MEASURE-INDUCT+ "length(x)" ("x"))
      (("" (EXPAND "quicksort" +)
        (("" (LIFT-IF)
          (("" (GROUND)
            (("1" (GRIND) NIL NIL)
             ("2" (EXPAND "fun")
              (("2" (INST? :COPY? T)
                (("2" (INST - "filter(cdr(x!1), above(car(x!1)))")
                  (("2" (GROUND)
                    (("1" (GRIND) NIL NIL)
                     ("2" (USE "length_filter") (("2" (GRIND) NIL NIL)) NIL)
                     ("3" (USE "length_filter") (("3" (GRIND) NIL NIL)) NIL)
                     ("4" (USE "length_filter") (("4" (GRIND) NIL NIL)) NIL))
                    NIL))
                  NIL))
                NIL))
              NIL))
            NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   ((|cons| ADT-CONSTRUCTOR-DECL "[[T, list] -> (cons?)]" |list_adt| NIL)
    (|append| DEF-DECL "list[T]" |list_props| NIL)
    (|null| ADT-CONSTRUCTOR-DECL "(null?)" |list_adt| NIL)
    (|null?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL)
    (|unjoin| CONST-DECL "well_fnd(cons?[T])" |treesort| NIL)
    (|cons?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL)
    (|fun| DEF-DECL "Range" |fusion| NIL)
    (|well_fnd| TYPE-EQ-DECL NIL |unfold| NIL)
    (|smaller| TYPE-EQ-DECL NIL |unfold| NIL)
    (PRED TYPE-EQ-DECL NIL |defined_types| NIL)
    (|quicksort| DEF-DECL "list[T]" |treesort| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|wf_nat| FORMULA-DECL NIL |naturalnumbers| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|naturalnumber| TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|measure_induction| FORMULA-DECL NIL |measure_induction| NIL)
    (|well_founded?| CONST-DECL "bool" |orders| NIL)
    (|pred| TYPE-EQ-DECL NIL |defined_types| NIL)
    (|above| CONST-DECL "bool" |treesort| NIL)
    (|length_filter| FORMULA-DECL NIL |treesort| NIL)
    (|nnint_plus_posint_is_posint| APPLICATION-JUDGEMENT "posint" |integers|
     NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|car| ADT-ACCESSOR-DECL "[(cons?) -> T]" |list_adt| NIL)
    (|below| CONST-DECL "bool" |treesort| NIL)
    (|cdr| ADT-ACCESSOR-DECL "[(cons?) -> list]" |list_adt| NIL)
    (|filter| DEF-DECL "(list_adt[T].every(p))" |filters| NIL)
    (|every| ADT-DEF-DECL "boolean" |list_adt| NIL)
    (|fusionqsort| CONST-DECL "list[T]" |treesort| NIL)
    (|flatten| CONST-DECL "list[T]" |treesort| NIL)
    (|fusion| FORMULA-DECL NIL |fusion| NIL)
    (T FORMAL-TYPE-DECL NIL |treesort| NIL)
    (|list| TYPE-DECL NIL |list_adt| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|length| DEF-DECL "nat" |list_props| NIL)
    (|mktree| CONST-DECL "binary_tree[T]" |treesort| NIL))
   SHOSTAK)
  (|quicksort_by_fusion-1| NIL 3943030978
   ("" (SIMPLIFY-WITH-REWRITES :REWRITES ("flatten" "mktree" "fusion"))
    ((""
      (MEASURE-INDUCT-AND-SIMPLIFY "length(x)" ("x") :EXPAND "fun" :IF-MATCH
       FIRST*)
      (("1" (APPLY (THEN (USE "length_filter") (ASSERT))) NIL)
       ("2" (APPLY (THEN (USE "length_filter") (ASSERT))) NIL)
       ("3" (APPLY (THEN (USE "length_filter") (ASSERT))) NIL))))
    NIL)
   ((|cons| ADT-CONSTRUCTOR-DECL "[[T, list] -> (cons?)]" |list_adt| NIL)
    (|append| DEF-DECL "list[T]" |list_props| NIL)
    (|null| ADT-CONSTRUCTOR-DECL "(null?)" |list_adt| NIL)
    (|null?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL)
    (|unjoin| CONST-DECL "well_fnd(cons?[T])" |treesort| NIL)
    (|cons?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL)
    (|fun| DEF-DECL "Range" |fusion| NIL)
    (|well_fnd| TYPE-EQ-DECL NIL |unfold| NIL)
    (|smaller| TYPE-EQ-DECL NIL |unfold| NIL)
    (PRED TYPE-EQ-DECL NIL |defined_types| NIL)
    (|quicksort| DEF-DECL "list[T]" |treesort| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|wf_nat| FORMULA-DECL NIL |naturalnumbers| NIL)
    (|measure_induction| FORMULA-DECL NIL |measure_induction| NIL)
    (|naturalnumber| TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|well_founded?| CONST-DECL "bool" |orders| NIL)
    (|pred| TYPE-EQ-DECL NIL |defined_types| NIL)
    (|above| CONST-DECL "bool" |treesort| NIL)
    (|nnint_plus_posint_is_posint| APPLICATION-JUDGEMENT "posint" |integers|
     NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|car| ADT-ACCESSOR-DECL "[(cons?) -> T]" |list_adt| NIL)
    (|below| CONST-DECL "bool" |treesort| NIL)
    (|cdr| ADT-ACCESSOR-DECL "[(cons?) -> list]" |list_adt| NIL)
    (|flatten| CONST-DECL "list[T]" |treesort| NIL)
    (|fusion| FORMULA-DECL NIL |fusion| NIL)
    (T FORMAL-TYPE-DECL NIL |treesort| NIL)
    (|list| TYPE-DECL NIL |list_adt| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|length| DEF-DECL "nat" |list_props| NIL)
    (|mktree| CONST-DECL "binary_tree[T]" |treesort| NIL))
   NIL))
 (|ordered?_TCC1| 0
  (|ordered?_TCC1-1| NIL 3943030978 ("" (TERMINATION-TCC) NIL NIL)
   ((|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|nnint_plus_posint_is_posint| APPLICATION-JUDGEMENT "posint" |integers|
     NIL)
    (|length| DEF-DECL "nat" |list_props| NIL))
   NIL (|ordered?| TERMINATION "treesort.ordered?(treesort.y)" "NIL")))
 (|every_mktree| 0
  (|every_mktree-1| NIL 3943030978
   (""
    (MEASURE-INDUCT-AND-SIMPLIFY "length(x)" ("x") :EXPAND "unfold" :IF-MATCH
     FIRST* :REWRITES "every_filter")
    (("1" (REWRITE "every_filter_uncurried") NIL NIL)
     ("2" (USE "length_filter") (("2" (ASSERT) NIL NIL)) NIL)
     ("3" (REWRITE "every_filter_uncurried") NIL NIL)
     ("4" (USE "length_filter") (("4" (ASSERT) NIL NIL)) NIL))
    NIL)
   ((|length_filter| FORMULA-DECL NIL |treesort| NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|every_filter_uncurried| FORMULA-DECL NIL |filters| NIL)
    (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL)
    (|above| CONST-DECL "bool" |treesort| NIL)
    (|posint_plus_nnint_is_posint| APPLICATION-JUDGEMENT "posint" |integers|
     NIL)
    (|filter| DEF-DECL "(list_adt[T].every(p))" |filters| NIL)
    (|cdr| ADT-ACCESSOR-DECL "[(cons?) -> list]" |list_adt| NIL)
    (|below| CONST-DECL "bool" |treesort| NIL)
    (|car| ADT-ACCESSOR-DECL "[(cons?) -> T]" |list_adt| NIL)
    (|nnint_plus_posint_is_posint| APPLICATION-JUDGEMENT "posint" |integers|
     NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (PRED TYPE-EQ-DECL NIL |defined_types| NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|every| ADT-DEF-DECL "boolean" |list_adt| NIL)
    (|binary_tree| TYPE-DECL NIL |binary_tree_adt| NIL)
    (|every| ADT-DEF-DECL "boolean" |binary_tree_adt| NIL)
    (|smaller| TYPE-EQ-DECL NIL |unfold| NIL)
    (|well_fnd| TYPE-EQ-DECL NIL |unfold| NIL)
    (|unfold| DEF-DECL "binary_tree" |unfold| NIL)
    (|cons?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL)
    (|unjoin| CONST-DECL "well_fnd(cons?[T])" |treesort| NIL)
    (|wf_nat| FORMULA-DECL NIL |naturalnumbers| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|length| DEF-DECL "nat" |list_props| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|naturalnumber| TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|list| TYPE-DECL NIL |list_adt| NIL)
    (T FORMAL-TYPE-DECL NIL |treesort| NIL)
    (|measure_induction| FORMULA-DECL NIL |measure_induction| NIL)
    (|well_founded?| CONST-DECL "bool" |orders| NIL)
    (|pred| TYPE-EQ-DECL NIL |defined_types| NIL))
   NIL))
 (|every_mktree_implies| 0
  (|every_mktree_implies-2| "partial proof in progress" 3943061163
   (""
    (MEASURE-INDUCT-AND-SIMPLIFY "length(x)" ("x") :REWRITES
     ("every_mktree" "every_filter_uncurried"))
    (("" (REWRITE "every_mktree")
      (("" (USE "every_implies[T]") (("" (GRIND) NIL NIL)) NIL)) NIL))
    NIL)
   ((|every_mktree| FORMULA-DECL NIL |treesort| NIL)
    (|every_implies| FORMULA-DECL NIL |list_props| NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (PRED TYPE-EQ-DECL NIL |defined_types| NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|every| ADT-DEF-DECL "boolean" |list_adt| NIL)
    (|binary_tree| TYPE-DECL NIL |binary_tree_adt| NIL)
    (|every| ADT-DEF-DECL "boolean" |binary_tree_adt| NIL)
    (|smaller| TYPE-EQ-DECL NIL |unfold| NIL)
    (|well_fnd| TYPE-EQ-DECL NIL |unfold| NIL)
    (|unfold| DEF-DECL "binary_tree" |unfold| NIL)
    (|cons?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL)
    (|unjoin| CONST-DECL "well_fnd(cons?[T])" |treesort| NIL)
    (|wf_nat| FORMULA-DECL NIL |naturalnumbers| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|length| DEF-DECL "nat" |list_props| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|naturalnumber| TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|list| TYPE-DECL NIL |list_adt| NIL)
    (T FORMAL-TYPE-DECL NIL |treesort| NIL)
    (|measure_induction| FORMULA-DECL NIL |measure_induction| NIL)
    (|well_founded?| CONST-DECL "bool" |orders| NIL)
    (|pred| TYPE-EQ-DECL NIL |defined_types| NIL))
   SHOSTAK)
  (|every_mktree_implies-1| NIL 3943030978
   (""
    (MEASURE-INDUCT-AND-SIMPLIFY "length(x)" ("x") :EXPAND "unfold" :IF-MATCH
     FIRST* :REWRITES "every_filter")
    (("1" (USE "length_filter") (("1" (ASSERT) NIL)))
     ("2" (USE "length_filter") (("2" (ASSERT) NIL)))
     ("3" (INST? -2) (("3" (PROP) NIL))))
    NIL)
   NIL NIL))
 (|ordered?_mktree| 0
  (|ordered?_mktree-1| NIL 3943030978
   ("" (SIMPLIFY-WITH-REWRITES :REWRITES ("mktree"))
    ((""
      (MEASURE-INDUCT-AND-SIMPLIFY "length(x)" ("x") :EXPAND "unfold" :IF-MATCH
       FIRST* :REWRITES ("checkall_mktree" "checkall_mktree_implies"))
      (("1" (APPLY (THEN (USE "length_filter") (ASSERT))) NIL)
       ("2" (APPLY (THEN (USE "length_filter") (ASSERT))) NIL)
       ("3" (USE "every_mktree_implies")
        (("3" (GRIND :REWRITES "filter_every")
          (("3" (TYPEPRED "treesort.<=") (("3" (GRIND :IF-MATCH ALL) NIL)))))))
       ("4" (APPLY (THEN (USE "length_filter") (ASSERT))) NIL)
       ("5" (REWRITE "every_mktree")
        (("5" (EXPAND "below") (("5" (REWRITE "filter_every") NIL)))))
       ("6" (APPLY (THEN (USE "length_filter") (ASSERT))) NIL))))
    NIL)
   ((|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL)
    (|above| CONST-DECL "bool" |treesort| NIL)
    (|posint_plus_nnint_is_posint| APPLICATION-JUDGEMENT "posint" |integers|
     NIL)
    (|nnint_plus_posint_is_posint| APPLICATION-JUDGEMENT "posint" |integers|
     NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|every| ADT-DEF-DECL "boolean" |list_adt| NIL)
    (|filter| DEF-DECL "(list_adt[T].every(p))" |filters| NIL)
    (|cdr| ADT-ACCESSOR-DECL "[(cons?) -> list]" |list_adt| NIL)
    (|below| CONST-DECL "bool" |treesort| NIL)
    (|car| ADT-ACCESSOR-DECL "[(cons?) -> T]" |list_adt| NIL)
    (|binary_tree| TYPE-DECL NIL |binary_tree_adt| NIL)
    (|total_order?| CONST-DECL "bool" |orders| NIL)
    (<= FORMAL-CONST-DECL "(total_order?[T])" |treesort| NIL)
    (|ordered?| DEF-DECL "bool" |obt| NIL)
    (PRED TYPE-EQ-DECL NIL |defined_types| NIL)
    (|smaller| TYPE-EQ-DECL NIL |unfold| NIL)
    (|well_fnd| TYPE-EQ-DECL NIL |unfold| NIL)
    (|unfold| DEF-DECL "binary_tree" |unfold| NIL)
    (|cons?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL)
    (|unjoin| CONST-DECL "well_fnd(cons?[T])" |treesort| NIL)
    (|wf_nat| FORMULA-DECL NIL |naturalnumbers| NIL)
    (|measure_induction| FORMULA-DECL NIL |measure_induction| NIL)
    (T FORMAL-TYPE-DECL NIL |treesort| NIL)
    (|list| TYPE-DECL NIL |list_adt| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|naturalnumber| TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|length| DEF-DECL "nat" |list_props| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|well_founded?| CONST-DECL "bool" |orders| NIL)
    (|pred| TYPE-EQ-DECL NIL |defined_types| NIL)
    (|length_filter| FORMULA-DECL NIL |treesort| NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|dichotomous?| CONST-DECL "bool" |orders| NIL)
    (|partial_order?| CONST-DECL "bool" |orders| NIL)
    (|antisymmetric?| CONST-DECL "bool" |relations| NIL)
    (|preorder?| CONST-DECL "bool" |orders| NIL)
    (|transitive?| CONST-DECL "bool" |relations| NIL)
    (|reflexive?| CONST-DECL "bool" |relations| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|every_mktree_implies| FORMULA-DECL NIL |treesort| NIL)
    (|every_mktree| FORMULA-DECL NIL |treesort| NIL)
    (|mktree| CONST-DECL "binary_tree[T]" |treesort| NIL))
   NIL))
 (|ordered?_append| 0
  (|ordered?_append-1| NIL 3943030978
   ("" (INDUCT "x")
    (("1" (INDUCT "y")
      (("1" (GRIND) NIL NIL)
       ("2" (SKOSIMP*)
        (("2" (SIMPLIFY-WITH-REWRITES :REWRITES ("ordered?" "append" "every"))
          (("2" (LIFT-IF +)
            (("2" (PROP)
              (("1" (GRIND) NIL NIL)
               ("2" (INST?)
                (("2" (LIFT-IF)
                  (("2" (PROP)
                    (("2" (BDDSIMP)
                      (("2" (TYPEPRED "treesort.<=")
                        (("2" (HIDE -2 3)
                          (("2" (SIMPLIFY-WITH-REWRITES :DEFS T)
                            (("2" (FLATTEN)
                              (("2" (HIDE -1 -3 -4)
                                (("2" (INST?)
                                  (("2" (INST - "cons1_var!1")
                                    (("2" (PROP) NIL NIL)) NIL))
                                  NIL))
                                NIL))
                              NIL))
                            NIL))
                          NIL))
                        NIL))
                      NIL))
                    NIL))
                  NIL))
                NIL))
              NIL))
            NIL))
          NIL))
        NIL))
      NIL)
     ("2" (SKOSIMP*)
      (("2" (SIMPLIFY-WITH-REWRITES :REWRITES ("ordered?" "append" "every"))
        (("2" (APPLY (THEN (REPEAT (LIFT-IF)) (PROP)))
          (("1"
            (SIMPLIFY-WITH-REWRITES :REWRITES ("ordered?" "append" "every"))
            NIL NIL)
           ("2"
            (SIMPLIFY-WITH-REWRITES :REWRITES ("ordered?" "append" "every"))
            NIL NIL)
           ("3" (SIMPLIFY-WITH-REWRITES :REWRITES "append")
            (("3" (INST?) (("3" (BDDSIMP) (("3" (GRIND) NIL NIL)) NIL)) NIL))
            NIL)
           ("4" (INST?)
            (("4" (REPLACE -1 :HIDE? T)
              (("4" (BDDSIMP)
                (("1" (SIMPLIFY-WITH-REWRITES :REWRITES ("append" "every"))
                  (("1" (SIMPLIFY-WITH-REWRITES :REWRITES ("append" "every"))
                    (("1" (FLATTEN)
                      (("1" (TYPEPRED "treesort.<=")
                        (("1" (SIMPLIFY-WITH-REWRITES :DEFS T)
                          (("1" (FLATTEN)
                            (("1" (HIDE -1 -3 -4 -6)
                              (("1"
                                (INST - "cons1_var!1" "car(cons2_var!1)" "a!1")
                                (("1" (PROP) NIL NIL)) NIL))
                              NIL))
                            NIL))
                          NIL))
                        NIL))
                      NIL))
                    NIL))
                  NIL)
                 ("2" (SIMPLIFY-WITH-REWRITES :REWRITES ("append" "every")) NIL
                  NIL)
                 ("3" (SIMPLIFY-WITH-REWRITES :REWRITES ("append" "every")) NIL
                  NIL))
                NIL))
              NIL))
            NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   ((|null?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL)
    (|null| ADT-CONSTRUCTOR-DECL "(null?)" |list_adt| NIL)
    (|car| ADT-ACCESSOR-DECL "[(cons?) -> T]" |list_adt| NIL)
    (|dichotomous?| CONST-DECL "bool" |orders| NIL)
    (|partial_order?| CONST-DECL "bool" |orders| NIL)
    (|antisymmetric?| CONST-DECL "bool" |relations| NIL)
    (|preorder?| CONST-DECL "bool" |orders| NIL)
    (|transitive?| CONST-DECL "bool" |relations| NIL)
    (|reflexive?| CONST-DECL "bool" |relations| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|list_induction| FORMULA-DECL NIL |list_adt| NIL)
    (T FORMAL-TYPE-DECL NIL |treesort| NIL)
    (<= FORMAL-CONST-DECL "(total_order?[T])" |treesort| NIL)
    (|total_order?| CONST-DECL "bool" |orders| NIL)
    (|pred| TYPE-EQ-DECL NIL |defined_types| NIL)
    (|every| ADT-DEF-DECL "boolean" |list_adt| NIL)
    (PRED TYPE-EQ-DECL NIL |defined_types| NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|cons| ADT-CONSTRUCTOR-DECL "[[T, list] -> (cons?)]" |list_adt| NIL)
    (|cons?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL)
    (|append| DEF-DECL "list[T]" |list_props| NIL)
    (|ordered?| DEF-DECL "bool" |treesort| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|list| TYPE-DECL NIL |list_adt| NIL))
   NIL))
 (|every_flatten| 0
  (|every_flatten-1| NIL 3943030978
   ("" (INDUCT-AND-SIMPLIFY "A" :REWRITES "every_append") NIL NIL)
   ((|every_append| FORMULA-DECL NIL |list_props| NIL)
    (|reduce| ADT-DEF-DECL "[binary_tree[T] -> range]" |binary_tree_adt_reduce|
     NIL)
    (|binary_tree_induction| FORMULA-DECL NIL |binary_tree_adt| NIL)
    (T FORMAL-TYPE-DECL NIL |treesort| NIL)
    (|flatten| CONST-DECL "list[T]" |treesort| NIL)
    (|every| ADT-DEF-DECL "boolean" |list_adt| NIL)
    (|list| TYPE-DECL NIL |list_adt| NIL)
    (|every| ADT-DEF-DECL "boolean" |binary_tree_adt| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (PRED TYPE-EQ-DECL NIL |defined_types| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|binary_tree| TYPE-DECL NIL |binary_tree_adt| NIL))
   NIL))
 (|ordered?_flatten| 0
  (|ordered?_flatten-1| NIL 3943030978
   ("" (INDUCT-AND-SIMPLIFY "A" :REWRITES ("ordered?_append" "every_flatten"))
    NIL NIL)
   ((|every_flatten| FORMULA-DECL NIL |treesort| NIL)
    (|ordered?_append| FORMULA-DECL NIL |treesort| NIL)
    (|reduce| ADT-DEF-DECL "[binary_tree[T] -> range]" |binary_tree_adt_reduce|
     NIL)
    (|binary_tree_induction| FORMULA-DECL NIL |binary_tree_adt| NIL)
    (T FORMAL-TYPE-DECL NIL |treesort| NIL)
    (|ordered?| DEF-DECL "bool" |obt| NIL)
    (<= FORMAL-CONST-DECL "(total_order?[T])" |treesort| NIL)
    (|total_order?| CONST-DECL "bool" |orders| NIL)
    (|pred| TYPE-EQ-DECL NIL |defined_types| NIL)
    (|flatten| CONST-DECL "list[T]" |treesort| NIL)
    (|ordered?| DEF-DECL "bool" |treesort| NIL)
    (|list| TYPE-DECL NIL |list_adt| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|binary_tree| TYPE-DECL NIL |binary_tree_adt| NIL))
   NIL))
 (|ordered?_fusionqsort| 0
  (|ordered?_fusionqsort-1| NIL 3943237677
   (""
    (INDUCT-AND-SIMPLIFY "x" :DEFS NIL :REWRITES
     ("ordered?_mktree" "ordered?_flatten" "fusionqsort"))
    NIL NIL)
   ((|list| TYPE-DECL NIL |list_adt| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|ordered?| DEF-DECL "bool" |treesort| NIL)
    (|fusionqsort| CONST-DECL "list[T]" |treesort| NIL)
    (T FORMAL-TYPE-DECL NIL |treesort| NIL)
    (|list_induction| FORMULA-DECL NIL |list_adt| NIL)
    (|ordered?_flatten| FORMULA-DECL NIL |treesort| NIL)
    (|ordered?_mktree| FORMULA-DECL NIL |treesort| NIL))
   SHOSTAK))
 (|count_TCC1| 0
  (|count_TCC1-1| NIL 3943030978 ("" (TERMINATION-TCC) NIL NIL)
   ((|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|nnint_plus_posint_is_posint| APPLICATION-JUDGEMENT "posint" |integers|
     NIL)
    (|length| DEF-DECL "nat" |list_props| NIL))
   NIL (|count| TERMINATION "treesort.count(treesort.a, treesort.y)" "NIL")))
 (|count_TCC2| 0
  (|count_TCC2-1| NIL 3943030978 ("" (TERMINATION-TCC) NIL NIL)
   ((|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|nnint_plus_posint_is_posint| APPLICATION-JUDGEMENT "posint" |integers|
     NIL)
    (|length| DEF-DECL "nat" |list_props| NIL))
   NIL (|count| TERMINATION "treesort.count(treesort.a, treesort.y)" "NIL")))
 (|count_filter| 0
  (|count_filter-1| NIL 3943030978 ("" (INDUCT-AND-REWRITE! "x") NIL NIL)
   ((|list| TYPE-DECL NIL |list_adt| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (PRED TYPE-EQ-DECL NIL |defined_types| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|count| DEF-DECL "nat" |treesort| NIL)
    (|pred| TYPE-EQ-DECL NIL |defined_types| NIL)
    (|every| ADT-DEF-DECL "boolean" |list_adt| NIL)
    (|filter| DEF-DECL "(list_adt[T].every(p))" |filters| NIL)
    (IF CONST-DECL
        "[boolean, T, T -> T]"
        |if_def|
        NIL)
    (T FORMAL-TYPE-DECL NIL |treesort| NIL)
    (|list_induction| FORMULA-DECL NIL |list_adt| NIL)
    (|posint_plus_nnint_is_posint| APPLICATION-JUDGEMENT "posint" |integers|
     NIL)
    (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL))
   NIL))
 (|count_append| 0
  (|count_append-1| NIL 3943030978 ("" (INDUCT-AND-REWRITE! "x") NIL NIL)
   ((|list| TYPE-DECL NIL |list_adt| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|count| DEF-DECL "nat" |treesort| NIL)
    (|append| DEF-DECL "list[T]" |list_props| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (T FORMAL-TYPE-DECL NIL |treesort| NIL)
    (|list_induction| FORMULA-DECL NIL |list_adt| NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL)
    (|posint_plus_nnint_is_posint| APPLICATION-JUDGEMENT "posint" |integers|
     NIL)
    (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL))
   NIL))
 (|length_quicksort| 0
  (|length_quicksort-1| NIL 3943030978
   (""
    (MEASURE-INDUCT-AND-SIMPLIFY "length(x)" ("x") :EXPAND "quicksort"
     :IF-MATCH FIRST* :REWRITES ("length_append" "filter_length"))
    NIL NIL)
   ((< CONST-DECL "bool" |reals| NIL)
    (|length| DEF-DECL "nat" |list_props| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|naturalnumber| TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|list| TYPE-DECL NIL |list_adt| NIL)
    (T FORMAL-TYPE-DECL NIL |treesort| NIL)
    (|measure_induction| FORMULA-DECL NIL |measure_induction| NIL)
    (|well_founded?| CONST-DECL "bool" |orders| NIL)
    (|pred| TYPE-EQ-DECL NIL |defined_types| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|quicksort| DEF-DECL "list[T]" |treesort| NIL)
    (|filter_length| FORMULA-DECL NIL |treesort| NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|nnint_plus_posint_is_posint| APPLICATION-JUDGEMENT "posint" |integers|
     NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|below| CONST-DECL "bool" |treesort| NIL)
    (|car| ADT-ACCESSOR-DECL "[(cons?) -> T]" |list_adt| NIL)
    (|above| CONST-DECL "bool" |treesort| NIL)
    (|cdr| ADT-ACCESSOR-DECL "[(cons?) -> list]" |list_adt| NIL)
    (|cons?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL)
    (|filter| DEF-DECL "(list_adt[T].every(p))" |filters| NIL)
    (|every| ADT-DEF-DECL "boolean" |list_adt| NIL)
    (PRED TYPE-EQ-DECL NIL |defined_types| NIL)
    (|length_append| FORMULA-DECL NIL |list_props| NIL)
    (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL)
    (|posint_plus_nnint_is_posint| APPLICATION-JUDGEMENT "posint" |integers|
     NIL)
    (|wf_nat| FORMULA-DECL NIL |naturalnumbers| NIL))
   NIL))
 (|count_quicksort| 0
  (|count_quicksort-1| NIL 3943030978
   (""
    (MEASURE-INDUCT-AND-SIMPLIFY "length(x)" ("x") :EXPAND "quicksort"
     :IF-MATCH FIRST* :REWRITES
     ("length_append" "count_filter" "count_append" "filter_length"
      "length_quicksort"))
    (("1" (HIDE -2 -3)
      (("1" (REWRITE "count_filter")
        (("1" (REWRITE "count_filter") (("1" (GRIND) NIL NIL)) NIL)) NIL))
      NIL)
     ("2" (APPLY (THEN (USE "length_filter") (ASSERT))) NIL NIL))
    NIL)
   ((|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|length_filter| FORMULA-DECL NIL |treesort| NIL)
    (|count_filter| FORMULA-DECL NIL |treesort| NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|posint_plus_nnint_is_posint| APPLICATION-JUDGEMENT "posint" |integers|
     NIL)
    (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL)
    (|nnint_plus_posint_is_posint| APPLICATION-JUDGEMENT "posint" |integers|
     NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|filter_length| FORMULA-DECL NIL |treesort| NIL)
    (|length_quicksort| FORMULA-DECL NIL |treesort| NIL)
    (PRED TYPE-EQ-DECL NIL |defined_types| NIL)
    (|every| ADT-DEF-DECL "boolean" |list_adt| NIL)
    (|filter| DEF-DECL "(list_adt[T].every(p))" |filters| NIL)
    (|cons?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL)
    (|cdr| ADT-ACCESSOR-DECL "[(cons?) -> list]" |list_adt| NIL)
    (|below| CONST-DECL "bool" |treesort| NIL)
    (|car| ADT-ACCESSOR-DECL "[(cons?) -> T]" |list_adt| NIL)
    (|above| CONST-DECL "bool" |treesort| NIL)
    (|count_append| FORMULA-DECL NIL |treesort| NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|count| DEF-DECL "nat" |treesort| NIL)
    (|quicksort| DEF-DECL "list[T]" |treesort| NIL)
    (|wf_nat| FORMULA-DECL NIL |naturalnumbers| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|length| DEF-DECL "nat" |list_props| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|naturalnumber| TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|list| TYPE-DECL NIL |list_adt| NIL)
    (T FORMAL-TYPE-DECL NIL |treesort| NIL)
    (|measure_induction| FORMULA-DECL NIL |measure_induction| NIL)
    (|well_founded?| CONST-DECL "bool" |orders| NIL)
    (|pred| TYPE-EQ-DECL NIL |defined_types| NIL))
   NIL))
 (|count_fusionqsort| 0
  (|count_fusionqsort-1| NIL 3943238106
   ("" (SKEEP*)
    (("" (REWRITE "quicksort_by_fusion" :DIR RL)
      (("" (REWRITE "count_quicksort") NIL NIL)) NIL))
    NIL)
   ((|quicksort_by_fusion| FORMULA-DECL NIL |treesort| NIL)
    (T FORMAL-TYPE-DECL NIL |treesort| NIL)
    (|list| TYPE-DECL NIL |list_adt| NIL)
    (|count_quicksort| FORMULA-DECL NIL |treesort| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (TRUE CONST-DECL "bool" |booleans| NIL))
   SHOSTAK))
 (|fusionqsort_fun| 0
  (|fusionqsort_fun-1| NIL 3943241552 ("" (GRIND :REWRITES "fusion") NIL NIL)
   ((|funsort| CONST-DECL "list[T]" |treesort| NIL)
    (|fusionqsort| CONST-DECL "list[T]" |treesort| NIL)
    (|flatten| CONST-DECL "list[T]" |treesort| NIL)
    (|fusion| FORMULA-DECL NIL |fusion| NIL)
    (T FORMAL-TYPE-DECL NIL |treesort| NIL)
    (|list| TYPE-DECL NIL |list_adt| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|length| DEF-DECL "nat" |list_props| NIL)
    (|mktree| CONST-DECL "binary_tree[T]" |treesort| NIL))
   SHOSTAK)))
(|test_treesort|
 (|test_quicksort1_TCC1| 0
  (|test_quicksort1_TCC1-1| NIL 3943413936 ("" (GRIND) NIL NIL)
   ((|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|every| ADT-DEF-DECL "boolean" |list_adt| NIL)
    (|exp2| DEF-DECL "posnat" |exp2| NIL))
   NIL
   (|test_quicksort1| SUBTYPE "(: 8, 3, 7, 4, 9, 5, 6, 2 :)" "list[uint32]")))
 (|genlist_TCC1| 0
  (|genlist_TCC1-1| NIL 3943413936 ("" (GRIND) NIL NIL)
   ((NIL APPLICATION-JUDGEMENT "above(n)" |exp2| NIL)
    (|every| ADT-DEF-DECL "boolean" |list_adt| NIL)
    (|exp2| DEF-DECL "posnat" |exp2| NIL))
   NIL (|genlist| SUBTYPE "(: 0 :)" "list[uint32]")))
 (|genlist_TCC2| 0
  (|genlist_TCC2-1| NIL 3943413936 ("" (GRIND) NIL NIL)
   ((|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (<= CONST-DECL "bool" |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (- CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|nonneg_int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (> CONST-DECL "bool" |reals| NIL)
    (|posnat| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|uint32| TYPE-EQ-DECL NIL |integertypes| NIL)
    (|minus_u32_i32| APPLICATION-JUDGEMENT "int64" |integertypes| NIL)
    (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|exp2| DEF-DECL "posnat" |exp2| NIL)
    (NIL APPLICATION-JUDGEMENT "above(n)" |exp2| NIL))
   NIL (|genlist| SUBTYPE "(number_fields.-)(test_treesort.n, 1)" "uint32")))
 (|genlist_TCC3| 0
  (|genlist_TCC3-1| NIL 3943413936 ("" (TERMINATION-TCC) NIL NIL) NIL NIL
   (|genlist| TERMINATION
    "test_treesort.genlist((number_fields.-)(test_treesort.n, 1))" "NIL"))))

