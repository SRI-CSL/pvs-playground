(HoareLogic
 (double_TCC1 0
  (double_TCC1-1 nil 3722300781 ("" (subtype-tcc) nil nil)
   ((empty_seq const-decl "finseq" finite_sequences nil)
    (add const-decl "finseq[T]" more_finseq nil))
   nil))
 (pair_TCC1 0
  (pair_TCC1-1 nil 3722300781 ("" (subtype-tcc) nil nil)
   ((empty_seq const-decl "finseq" finite_sequences nil)
    (add const-decl "finseq[T]" more_finseq nil))
   nil))
 (first_TCC1 0
  (first_TCC1-1 nil 3722300781 ("" (subtype-tcc) nil nil) nil nil))
 (last_TCC1 0
  (last_TCC1-1 nil 3722300781 ("" (subtype-tcc) nil nil) nil nil))
 (splice_TCC1 0
  (splice_TCC1-1 nil 3722300781 ("" (subtype-tcc) nil nil)
   ((O const-decl "finseq" finite_sequences nil)) nil))
 (programSize_TCC1 0
  (programSize_TCC1-1 nil 3722300781 ("" (termination-tcc) nil nil)
   ((<< adt-def-decl "(strict_well_founded?[program])" HoareLogic nil))
   nil))
 (programSize_TCC2 0
  (programSize_TCC2-1 nil 3722300781 ("" (termination-tcc) nil nil)
   ((<< adt-def-decl "(strict_well_founded?[program])" HoareLogic nil))
   nil))
 (programSize_TCC3 0
  (programSize_TCC3-1 nil 3722300781 ("" (termination-tcc) nil nil)
   ((<< adt-def-decl "(strict_well_founded?[program])" HoareLogic nil))
   nil))
 (programSize_TCC4 0
  (programSize_TCC4-1 nil 3722390428 ("" (termination-tcc) nil nil)
   ((<< adt-def-decl "(strict_well_founded?[program])" HoareLogic nil))
   nil))
 (programSize_TCC5 0
  (programSize_TCC5-1 nil 3722390428 ("" (termination-tcc) nil nil)
   ((<< adt-def-decl "(strict_well_founded?[program])" HoareLogic nil))
   nil))
 (meaning_TCC1 0
  (meaning_TCC1-1 nil 3722300781 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (value nonempty-type-decl nil HoareLogic nil)
    (state type-eq-decl nil HoareLogic nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (trace type-eq-decl nil HoareLogic nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (programSize def-decl "nat" HoareLogic nil)
    (< def-decl "bool" ordinals nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (odd_plus_even_is_odd application-judgement "odd_int" integers nil)
    (first const-decl "state" HoareLogic nil)
    (lex2 const-decl "ordinal" lex2 nil))
   nil))
 (meaning_TCC2 0
  (meaning_TCC2-1 nil 3722300781 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (value nonempty-type-decl nil HoareLogic nil)
    (state type-eq-decl nil HoareLogic nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (trace type-eq-decl nil HoareLogic nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (programSize def-decl "nat" HoareLogic nil)
    (< def-decl "bool" ordinals nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (first const-decl "state" HoareLogic nil)
    (lex2 const-decl "ordinal" lex2 nil))
   nil))
 (meaning_TCC3 0
  (meaning_TCC3-1 nil 3722300781 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (value nonempty-type-decl nil HoareLogic nil)
    (state type-eq-decl nil HoareLogic nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (trace type-eq-decl nil HoareLogic nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (< def-decl "bool" ordinals nil)
    (programSize def-decl "nat" HoareLogic nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (first const-decl "state" HoareLogic nil)
    (O const-decl "finseq" finite_sequences nil)
    (splice const-decl "trace" HoareLogic nil)
    (last const-decl "state" HoareLogic nil)
    (lex2 const-decl "ordinal" lex2 nil))
   nil))
 (meaning_TCC4 0
  (meaning_TCC4-1 nil 3722300781 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (value nonempty-type-decl nil HoareLogic nil)
    (state type-eq-decl nil HoareLogic nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (trace type-eq-decl nil HoareLogic nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (< def-decl "bool" ordinals nil)
    (programSize def-decl "nat" HoareLogic nil)
    (first const-decl "state" HoareLogic nil)
    (O const-decl "finseq" finite_sequences nil)
    (splice const-decl "trace" HoareLogic nil)
    (last const-decl "state" HoareLogic nil)
    (lex2 const-decl "ordinal" lex2 nil))
   nil))
 (meaning_TCC5 0
  (meaning_TCC5-1 nil 3722390428 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (value nonempty-type-decl nil HoareLogic nil)
    (state type-eq-decl nil HoareLogic nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (trace type-eq-decl nil HoareLogic nil)
    (< def-decl "bool" ordinals nil)
    (programSize def-decl "nat" HoareLogic nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (O const-decl "finseq" finite_sequences nil)
    (splice const-decl "trace" HoareLogic nil)
    (first const-decl "state" HoareLogic nil)
    (last const-decl "state" HoareLogic nil)
    (lex2 const-decl "ordinal" lex2 nil))
   nil))
 (meaning_TCC6 0
  (meaning_TCC6-1 nil 3722390428 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (value nonempty-type-decl nil HoareLogic nil)
    (state type-eq-decl nil HoareLogic nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (trace type-eq-decl nil HoareLogic nil)
    (< def-decl "bool" ordinals nil)
    (programSize def-decl "nat" HoareLogic nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (O const-decl "finseq" finite_sequences nil)
    (splice const-decl "trace" HoareLogic nil)
    (first const-decl "state" HoareLogic nil)
    (last const-decl "state" HoareLogic nil)
    (lex2 const-decl "ordinal" lex2 nil))
   nil))
 (skip_rule 0
  (skip_rule-1 nil 3722301795 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (value nonempty-type-decl nil HoareLogic nil)
    (state type-eq-decl nil HoareLogic nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (trace type-eq-decl nil HoareLogic nil)
    (first const-decl "state" HoareLogic nil)
    (last const-decl "state" HoareLogic nil)
    (meaning def-decl "bool" HoareLogic nil)
    (triple_holds const-decl "bool" HoareLogic nil)
    (triple_valid const-decl "bool" HoareLogic nil))
   shostak))
 (assignment_rule 0
  (assignment_rule-1 nil 3722302039 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (value nonempty-type-decl nil HoareLogic nil)
    (state type-eq-decl nil HoareLogic nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (trace type-eq-decl nil HoareLogic nil)
    (first const-decl "state" HoareLogic nil)
    (O const-decl "T3" function_props nil)
    (last const-decl "state" HoareLogic nil)
    (meaning def-decl "bool" HoareLogic nil)
    (triple_holds const-decl "bool" HoareLogic nil)
    (triple_valid const-decl "bool" HoareLogic nil))
   shostak))
 (conditional_rule 0
  (conditional_rule-1 nil 3722303966 ("" (grind) nil nil)
   ((real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (trace type-eq-decl nil HoareLogic nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (state type-eq-decl nil HoareLogic nil)
    (value nonempty-type-decl nil HoareLogic nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (first const-decl "state" HoareLogic nil)
    (strengthen const-decl "bool" HoareLogic nil)
    (last const-decl "state" HoareLogic nil)
    (triple_holds const-decl "bool" HoareLogic nil)
    (triple_valid const-decl "bool" HoareLogic nil)
    (neg const-decl "bool" HoareLogic nil)
    (meaning def-decl "bool" HoareLogic nil))
   shostak))
 (while_rule 0
  (while_rule-1 nil 3722306419
   ("" (skeep)
    (("" (expand "triple_valid")
      (("" (measure-induct+ "X`length" "X")
        (("" (expand "triple_holds")
          (("" (expand "meaning" +)
            (("" (skeep)
              (("" (ground)
                (("1" (skeep)
                  (("1" (inst - "Z")
                    (("1" (inst - "Y")
                      (("1" (grind :exclude "meaning") nil nil)) nil))
                    nil))
                  nil)
                 ("2" (grind :exclude "meaning") nil nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((triple_valid const-decl "bool" HoareLogic nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (first const-decl "state" HoareLogic nil)
    (last const-decl "state" HoareLogic nil)
    (O const-decl "finseq" finite_sequences nil)
    (splice const-decl "trace" HoareLogic nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (meaning def-decl "bool" HoareLogic nil)
    (neg const-decl "bool" HoareLogic nil)
    (strengthen const-decl "bool" HoareLogic nil)
    (test type-eq-decl nil HoareLogic nil)
    (while adt-constructor-decl "[[test, program] -> (while?)]"
     HoareLogic nil)
    (while? adt-recognizer-decl "[program -> boolean]" HoareLogic nil)
    (triple_holds const-decl "bool" HoareLogic nil)
    (program type-decl nil HoareLogic nil)
    (assertion type-eq-decl nil HoareLogic nil)
    (wf_nat formula-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (naturalnumber type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (trace type-eq-decl nil HoareLogic nil)
    (> const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (state type-eq-decl nil HoareLogic nil)
    (value nonempty-type-decl nil HoareLogic nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (measure_induction formula-decl nil measure_induction nil)
    (well_founded? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil))
   shostak))
 (composition_rule 0
  (composition_rule-1 nil 3722391099 ("" (grind) nil nil)
   ((real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (trace type-eq-decl nil HoareLogic nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (state type-eq-decl nil HoareLogic nil)
    (value nonempty-type-decl nil HoareLogic nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (first const-decl "state" HoareLogic nil)
    (last const-decl "state" HoareLogic nil)
    (triple_holds const-decl "bool" HoareLogic nil)
    (triple_valid const-decl "bool" HoareLogic nil)
    (O const-decl "finseq" finite_sequences nil)
    (splice const-decl "trace" HoareLogic nil)
    (meaning def-decl "bool" HoareLogic nil))
   shostak))
 (conseq_rule 0
  (conseq_rule-1 nil 3722391281 ("" (grind) nil nil)
   ((numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (trace type-eq-decl nil HoareLogic nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (state type-eq-decl nil HoareLogic nil)
    (value nonempty-type-decl nil HoareLogic nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (conseq const-decl "bool" HoareLogic nil)
    (first const-decl "state" HoareLogic nil)
    (last const-decl "state" HoareLogic nil)
    (triple_holds const-decl "bool" HoareLogic nil)
    (triple_valid const-decl "bool" HoareLogic nil))
   shostak))
 (Proof?_TCC1 0
  (Proof?_TCC1-1 nil 3722704279 ("" (termination-tcc) nil nil)
   ((<< adt-def-decl "(strict_well_founded?[preProof])" HoareLogic
     nil))
   nil))
 (Proof?_TCC2 0
  (Proof?_TCC2-1 nil 3722704279 ("" (termination-tcc) nil nil)
   ((<< adt-def-decl "(strict_well_founded?[preProof])" HoareLogic
     nil))
   nil))
 (Proof?_TCC3 0
  (Proof?_TCC3-1 nil 3722704279 ("" (termination-tcc) nil nil)
   ((<< adt-def-decl "(strict_well_founded?[preProof])" HoareLogic
     nil))
   nil))
 (Proof?_TCC4 0
  (Proof?_TCC4-1 nil 3722704279 ("" (termination-tcc) nil nil)
   ((<< adt-def-decl "(strict_well_founded?[preProof])" HoareLogic
     nil))
   nil))
 (Proof?_TCC5 0
  (Proof?_TCC5-1 nil 3722704279 ("" (termination-tcc) nil nil)
   ((<< adt-def-decl "(strict_well_founded?[preProof])" HoareLogic
     nil))
   nil))
 (Proof?_TCC6 0
  (Proof?_TCC6-1 nil 3722704279 ("" (termination-tcc) nil nil)
   ((<< adt-def-decl "(strict_well_founded?[preProof])" HoareLogic nil)
    (conseq const-decl "bool" HoareLogic nil))
   nil))
 (soundness 0
  (soundness-1 nil 3722704280
   ("" (induct "M")
    (("1" (grind :rewrites "skip_rule") nil nil)
     ("2" (grind :rewrites "assignment_rule") nil nil)
     ("3" (grind :if-match nil :exclude "triple_valid")
      (("3" (forward-chain "conditional_rule")
        (("3" (replace-eta "ift_step1_var!1`prog" "(ift?)") nil nil))
        nil))
      nil)
     ("4" (grind :if-match nil :exclude "triple_valid")
      (("4" (forward-chain "while_rule")
        (("4" (replace-eta "while_step1_var!1`prog" "(while?)") nil
          nil))
        nil))
      nil)
     ("5" (grind :if-match nil :exclude "triple_valid")
      (("5" (forward-chain "composition_rule")
        (("5" (replace-eta "seq_step1_var!1`prog" "(seq?)") nil nil))
        nil))
      nil)
     ("6" (grind :exclude ("conseq" "triple_valid"))
      (("6" (forward-chain "conseq_rule") nil nil)) nil))
    nil)
   ((conseq_rule formula-decl nil HoareLogic nil)
    (program_seq_eta formula-decl nil HoareLogic nil)
    (right adt-accessor-decl "[(seq?) -> program]" HoareLogic nil)
    (left adt-accessor-decl "[(seq?) -> program]" HoareLogic nil)
    (seq? adt-recognizer-decl "[program -> boolean]" HoareLogic nil)
    (composition_rule formula-decl nil HoareLogic nil)
    (program_while_eta formula-decl nil HoareLogic nil)
    (body adt-accessor-decl "[(while?) -> program]" HoareLogic nil)
    (wcond adt-accessor-decl "[(while?) -> test]" HoareLogic nil)
    (while? adt-recognizer-decl "[program -> boolean]" HoareLogic nil)
    (while_rule formula-decl nil HoareLogic nil)
    (program_ift_eta formula-decl nil HoareLogic nil)
    (elseprog adt-accessor-decl "[(ift?) -> program]" HoareLogic nil)
    (thenprog adt-accessor-decl "[(ift?) -> program]" HoareLogic nil)
    (ifcond adt-accessor-decl "[(ift?) -> test]" HoareLogic nil)
    (ift? adt-recognizer-decl "[program -> boolean]" HoareLogic nil)
    (test type-eq-decl nil HoareLogic nil)
    (conditional_rule formula-decl nil HoareLogic nil)
    (O const-decl "T3" function_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (meaning def-decl "bool" HoareLogic nil)
    (trace type-eq-decl nil HoareLogic nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (state type-eq-decl nil HoareLogic nil)
    (value nonempty-type-decl nil HoareLogic nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (triple_valid const-decl "bool" HoareLogic nil)
    (triple_holds const-decl "bool" HoareLogic nil)
    (last const-decl "state" HoareLogic nil)
    (first const-decl "state" HoareLogic nil)
    (preProof_induction formula-decl nil HoareLogic nil)
    (conclusion shared-adt-accessor-decl "[preProof -> triple]"
     HoareLogic nil)
    (valid const-decl "bool" HoareLogic nil)
    (triple type-eq-decl nil HoareLogic nil)
    (program type-decl nil HoareLogic nil)
    (assertion type-eq-decl nil HoareLogic nil)
    (Proof? def-decl "bool" HoareLogic nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (preProof type-decl nil HoareLogic nil))
   shostak))
 (wlp_valid 0
  (wlp_valid-1 nil 3722400549
   ("" (induct "S")
    (("1" (grind) nil nil) ("2" (grind) nil nil)
     ("3" (lazy-grind :if-match all :polarity? t) nil nil)
     ("4" (skeep*)
      (("4" (reduce)
        (("4" (install-rewrites :defs t :theories "HoareLogic")
          (("4" (stop-rewrite "meaning") (("4" (reduce) nil nil)) nil))
          nil))
        nil))
      nil)
     ("5" (lazy-grind :if-match all :polarity? t :exclude "meaning")
      nil nil))
    nil)
   ((test type-eq-decl nil HoareLogic nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (first const-decl "state" HoareLogic nil)
    (last const-decl "state" HoareLogic nil)
    (meaning def-decl "bool" HoareLogic nil)
    (triple_holds const-decl "bool" HoareLogic nil)
    (even_minus_odd_is_odd application-judgement "odd_int" integers
     nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (trace type-eq-decl nil HoareLogic nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (> const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (program_induction formula-decl nil HoareLogic nil)
    (wlp const-decl "bool" HoareLogic nil)
    (triple_valid const-decl "bool" HoareLogic nil)
    (assertion type-eq-decl nil HoareLogic nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (state type-eq-decl nil HoareLogic nil)
    (value nonempty-type-decl nil HoareLogic nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (program type-decl nil HoareLogic nil))
   shostak))
 (wlp_weak 0
  (wlp_weak-1 nil 3722747011
   ("" (skeep)
    (("" (use "conseq_rule" :subst ("P1" "wlp(S)(Q)" "Q1" "Q"))
      (("" (grind :rewrites "wlp_valid") nil nil)) nil))
    nil)
   ((conseq_rule formula-decl nil HoareLogic nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (value nonempty-type-decl nil HoareLogic nil)
    (state type-eq-decl nil HoareLogic nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (assertion type-eq-decl nil HoareLogic nil)
    (program type-decl nil HoareLogic nil)
    (wlp const-decl "bool" HoareLogic nil)
    (wlp_valid formula-decl nil HoareLogic nil)
    (conseq const-decl "bool" HoareLogic nil)
    (last const-decl "state" HoareLogic nil)
    (first const-decl "state" HoareLogic nil)
    (triple_valid const-decl "bool" HoareLogic nil)
    (triple_holds const-decl "bool" HoareLogic nil))
   shostak))
 (wlp_proof 0
  (wlp_proof-1 nil 3723003545
   ("" (induct "S")
    (("1" (skeep)
      (("1" (inst + "skip_step(mkTriple(wlp(skip)(Q), skip, Q))")
        (("1" (grind)
          (("1" (apply-extensionality)
            (("1" (grind)
              (("1" (inst - "(: x!1, x!1 :)")
                (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("2" (skeep*)
      (("2"
        (inst +
         "assign_step(mkTriple(wlp(assign(assign1_var))(Q), assign(assign1_var),
                                        Q))")
        (("2" (grind)
          (("2" (apply-extensionality :hide? t)
            (("2" (grind)
              (("2" (inst - "(: x!1, assign1_var(x!1) :)")
                (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("3" (skeep*)
      (("3" (inst - "Q")
        (("3" (inst - "Q")
          (("3" (skeep*)
            (("3"
              (inst +
               "ift_step(mkTriple(wlp(ift(ift1_var, ift2_var, ift3_var))(Q), ift(ift1_var, ift2_var, ift3_var), Q), conseq_step(mkTriple(strengthen(wlp(ift(ift1_var, ift2_var, ift3_var))(Q), ift1_var), ift2_var, Q), M), conseq_step(mkTriple(strengthen(wlp(ift(ift1_var, ift2_var, ift3_var))(Q), neg(ift1_var)), ift3_var, Q), M!1))")
              (("3" (grind) nil nil)) nil))
            nil))
          nil))
        nil))
      nil)
     ("4" (skeep*)
      (("4" (inst - "wlp(while(while1_var, while2_var))(Q)")
        (("4" (skeep)
          (("4"
            (inst +
             "conseq_step(mkTriple(wlp(while(while1_var, while2_var))(Q),
                                            while(while1_var, while2_var), Q), while_step(mkTriple(wlp(while(while1_var, while2_var))(Q),
                                            while(while1_var, while2_var), strengthen(wlp(while(while1_var, while2_var))(Q), neg(while1_var))), conseq_step(mkTriple(strengthen(wlp(while(while1_var, while2_var))(Q), while1_var), while2_var, wlp(while(while1_var, while2_var))(Q)), M)))")
            (("4" (grind :if-match nil :exclude "meaning")
              (("1" (grind :exclude "meaning") nil nil)
               ("2" (inst - "splice(X!1, X!2)")
                (("2" (grind :exclude "meaning")
                  (("2" (expand "meaning" +)
                    (("2" (grind :exclude "meaning") nil nil)) nil))
                  nil))
                nil)
               ("3" (inst - "(: s!1, s!1 :)")
                (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("5" (skeep*)
      (("5" (inst - "wlp(seq2_var)(Q)")
        (("5" (inst?)
          (("5" (skeep*)
            (("5"
              (inst +
               "seq_step(mkTriple(wlp(seq(seq1_var, seq2_var))(Q),
                                    seq(seq1_var, seq2_var), Q), M, M!1)")
              (("5" (grind :exclude "wlp")
                (("5" (hide -)
                  (("5" (apply-extensionality :hide? t)
                    (("5" (grind :if-match nil)
                      (("1" (inst?)
                        (("1" (ground)
                          (("1" (inst?) (("1" (ground) nil nil)) nil))
                          nil))
                        nil)
                       ("2" (inst - "splice(X!1, X!2)")
                        (("2" (grind :polarity? t) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((seq_step? adt-recognizer-decl "[preProof -> boolean]" HoareLogic
     nil)
    (seq_step adt-constructor-decl
     "[[triple, preProof, preProof] -> (seq_step?)]" HoareLogic nil)
    (seq? adt-recognizer-decl "[program -> boolean]" HoareLogic nil)
    (seq adt-constructor-decl "[[program, program] -> (seq?)]"
     HoareLogic nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (O const-decl "finseq" finite_sequences nil)
    (splice const-decl "trace" HoareLogic nil)
    (s!1 skolem-const-decl "state" HoareLogic nil)
    (while_step adt-constructor-decl
     "[[triple, preProof] -> (while_step?)]" HoareLogic nil)
    (while_step? adt-recognizer-decl "[preProof -> boolean]" HoareLogic
     nil)
    (while? adt-recognizer-decl "[program -> boolean]" HoareLogic nil)
    (while adt-constructor-decl "[[test, program] -> (while?)]"
     HoareLogic nil)
    (ift_step? adt-recognizer-decl "[preProof -> boolean]" HoareLogic
     nil)
    (ift_step adt-constructor-decl
     "[[triple, preProof, preProof] -> (ift_step?)]" HoareLogic nil)
    (ift? adt-recognizer-decl "[program -> boolean]" HoareLogic nil)
    (ift adt-constructor-decl "[[test, program, program] -> (ift?)]"
     HoareLogic nil)
    (test type-eq-decl nil HoareLogic nil)
    (conseq_step? adt-recognizer-decl "[preProof -> boolean]"
     HoareLogic nil)
    (conseq_step adt-constructor-decl
     "[[triple, preProof] -> (conseq_step?)]" HoareLogic nil)
    (strengthen const-decl "bool" HoareLogic nil)
    (neg const-decl "bool" HoareLogic nil)
    (conseq const-decl "bool" HoareLogic nil)
    (assign1_var skolem-const-decl "assignment" HoareLogic nil)
    (every adt-def-decl "boolean" list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (x!1 skolem-const-decl "state" HoareLogic nil)
    (O const-decl "T3" function_props nil)
    (assignment type-eq-decl nil HoareLogic nil)
    (assign adt-constructor-decl "[assignment -> (assign?)]" HoareLogic
     nil)
    (assign? adt-recognizer-decl "[program -> boolean]" HoareLogic nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (assign_step adt-constructor-decl "[triple -> (assign_step?)]"
     HoareLogic nil)
    (assign_step? adt-recognizer-decl "[preProof -> boolean]"
     HoareLogic nil)
    (Proof? def-decl "bool" HoareLogic nil)
    (trace type-eq-decl nil HoareLogic nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (> const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nth def-decl "T" list_props nil)
    (length def-decl "nat" list_props nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (x!1 skolem-const-decl "state" HoareLogic nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (list2finseq const-decl "finseq[T]" list2finseq nil)
    (list type-decl nil list_adt nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (last const-decl "state" HoareLogic nil)
    (first const-decl "state" HoareLogic nil)
    (meaning def-decl "bool" HoareLogic nil)
    (skip adt-constructor-decl "(skip?)" HoareLogic nil)
    (skip? adt-recognizer-decl "[program -> boolean]" HoareLogic nil)
    (skip_step adt-constructor-decl "[triple -> (skip_step?)]"
     HoareLogic nil)
    (skip_step? adt-recognizer-decl "[preProof -> boolean]" HoareLogic
     nil)
    (program_induction formula-decl nil HoareLogic nil)
    (wlp const-decl "bool" HoareLogic nil)
    (mkTriple const-decl "triple" HoareLogic nil)
    (Proves const-decl "bool" HoareLogic nil)
    (triple type-eq-decl nil HoareLogic nil)
    (preProof type-decl nil HoareLogic nil)
    (assertion type-eq-decl nil HoareLogic nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (state type-eq-decl nil HoareLogic nil)
    (value nonempty-type-decl nil HoareLogic nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (program type-decl nil HoareLogic nil))
   shostak))
 (completeness 0
  (completeness-1 nil 3723003631
   ("" (skeep)
    (("" (lemma "wlp_proof" :subst ("S" "H`prog" "Q" "H`post"))
      (("" (skeep)
        (("" (inst + "conseq_step(H, M)") (("" (grind) nil nil)) nil))
        nil))
      nil))
    nil)
   ((triple type-eq-decl nil HoareLogic nil)
    (program type-decl nil HoareLogic nil)
    (assertion type-eq-decl nil HoareLogic nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (state type-eq-decl nil HoareLogic nil)
    (value nonempty-type-decl nil HoareLogic nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (wlp_proof formula-decl nil HoareLogic nil)
    (conseq_step adt-constructor-decl
     "[[triple, preProof] -> (conseq_step?)]" HoareLogic nil)
    (conseq_step? adt-recognizer-decl "[preProof -> boolean]"
     HoareLogic nil)
    (preProof type-decl nil HoareLogic nil)
    (wlp const-decl "bool" HoareLogic nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (> const-decl "bool" reals nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (trace type-eq-decl nil HoareLogic nil)
    (Proof? def-decl "bool" HoareLogic nil)
    (conseq const-decl "bool" HoareLogic nil)
    (valid const-decl "bool" HoareLogic nil)
    (triple_valid const-decl "bool" HoareLogic nil)
    (triple_holds const-decl "bool" HoareLogic nil)
    (last const-decl "state" HoareLogic nil)
    (first const-decl "state" HoareLogic nil)
    (Proves const-decl "bool" HoareLogic nil)
    (mkTriple const-decl "triple" HoareLogic nil))
   shostak)))

